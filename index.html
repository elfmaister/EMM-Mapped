<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>EMM 3D Map (VR Ready)</title>
<style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #loading {
        position: absolute; top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        color: white; font-family: Arial; z-index: 100;
    }
    #leaderboard {
        position: absolute; top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0,0,0,0.8); color: white;
        padding: 20px; border-radius: 8px; font-family: Arial;
        z-index: 200; display: none;
        max-height: 80vh; overflow-y: auto;
    }
    #leaderboard h2 { margin: 0 0 10px; text-align: center; }
    #leaderboard table { width: 100%; border-collapse: collapse; }
    #leaderboard th, #leaderboard td {
        padding: 8px; text-align: left; border-bottom: 1px solid #555;
    }
</style>
</head>
<body>
<div id="loading">Loading map...</div>
<div id="leaderboard">
    <h2>Fastest Velocities</h2>
    <table>
        <thead><tr><th>Player</th><th>Max Velocity (u/s)</th></tr></thead>
        <tbody id="leaderboard-body"></tbody>
    </table>
</div>

<script type="module">
import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js';
import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/loaders/GLTFLoader.js';
import { VRButton } from './VRButton.js'; // locally hosted ES module

// Scene setup
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87CEEB);
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 20000);
const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.xr.enabled = true;
document.body.appendChild(renderer.domElement);
document.body.appendChild(VRButton.createButton(renderer));

// Lighting
scene.add(new THREE.AmbientLight(0xffffff, 1.0));
const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
dirLight.position.set(100,200,100);
scene.add(dirLight);

// Player setup
const playerGeometry = new THREE.CylinderGeometry(1,1,2,8);
const playerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
const playerMeshes = new Map();
const maxVelocities = new Map();
const latestPlayerData = {};
let followTarget = null;

// Leaderboard
function updateLeaderboard() {
    const tbody = document.getElementById("leaderboard-body");
    tbody.innerHTML = "";
    Array.from(maxVelocities.entries())
        .sort((a,b) => b[1]-a[1])
        .forEach(([name,vel],i) => {
            if(name==="unconnected") return;
            let medal = i===0?"ðŸ¥‡ ":i===1?"ðŸ¥ˆ ":i===2?"ðŸ¥‰ ":"";
            const row = document.createElement("tr");
            row.innerHTML = `<td>${medal}${name}</td><td>${vel.toFixed(2)}</td>`;
            tbody.appendChild(row);
        });
}

// Spawn or update players
function spawnRealtimePlayerIndicator(data) {
    if(!data || !data.name) return;
    const offsetX=6498.061, offsetY=-7027.718, offsetZ=-10647.092, testHeight=45, scaleFactor=39.269, modelScale=2.5;
    const baseX=(data.x-offsetX)/scaleFactor;
    const baseY=(data.z-offsetZ)/scaleFactor;
    const baseZ=-(data.y-offsetY)/scaleFactor;
    const posX=baseX*modelScale;
    const posY=baseY*modelScale+testHeight+1;
    const posZ=baseZ*modelScale;

    // Track max velocity
    if(data.vel!==undefined){
        const adjustedVel = data.vel/10;
        const currentMax = maxVelocities.get(data.name) || 0;
        if(adjustedVel > currentMax){
            maxVelocities.set(data.name, adjustedVel);
            localStorage.setItem("maxVelocities", JSON.stringify(Object.fromEntries(maxVelocities)));
            updateLeaderboard();
        }
    }

    if(!playerMeshes.has(data.name)){
        const mesh = new THREE.Mesh(playerGeometry, playerMaterial);
        scene.add(mesh);

        const canvas = document.createElement("canvas");
        canvas.width=256; canvas.height=64;
        const ctx = canvas.getContext("2d");
        ctx.fillStyle="rgba(0,0,0,0.7)";
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle="white";
        ctx.font="bold 20px Arial";
        ctx.fillText(data.name,10,35);
        const label = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas) }));
        label.scale.set(20,5,1);
        scene.add(label);

        playerMeshes.set(data.name, { mesh, label, targetPos: new THREE.Vector3() });
    }

    const player = playerMeshes.get(data.name);
    player.targetPos.set(posX,posY,posZ);
    player.label.position.set(posX,posY+3,posZ);
    latestPlayerData[data.name] = data;
}

// Load map
const loader = new GLTFLoader();
loader.load('/gm_bigcity/scene.gltf', gltf => {
    scene.add(gltf.scene);
    gltf.scene.scale.set(2.5,2.5,2.5);
    gltf.scene.position.set(0,15,0);
    document.getElementById("loading").style.display="none";
    initRealtimePlayer();
}, xhr => {
    const percent = (xhr.loaded/xhr.total*100).toFixed(2);
    document.getElementById("loading").innerText=`Loading map... ${percent}%`;
}, err=>{
    console.error("Failed to load map:", err);
    document.getElementById("loading").innerText="Failed to load map.";
    setTimeout(()=>document.getElementById("loading").style.display="none",3000);
});

// WebSocket
function initRealtimePlayer(){
    const socket = new WebSocket("wss://emm-mapped.onrender.com/data");
    socket.onopen = ()=>console.log("WebSocket connected");
    socket.onmessage = (event)=>{
        try{
            const msg = JSON.parse(event.data);
            if(msg.players){
                const current = new Set();
                msg.players.forEach(p=>{ spawnRealtimePlayerIndicator(p); current.add(p.name); });
                playerMeshes.forEach((pl,name)=>{
                    if(!current.has(name)){
                        scene.remove(pl.mesh); scene.remove(pl.label);
                        playerMeshes.delete(name);
                        updateLeaderboard();
                    }
                });
            }
        }catch(e){console.error("Bad WS message:",e);}
    };
    socket.onclose = ()=>console.log("WebSocket closed");
    socket.onerror = e=>console.error("WebSocket error:", e);
}

// Freecam controls
const moveSpeed = 50;
const keys = {w:0,a:0,s:0,d:0,space:0,ctrl:0,tab:0};
const clock = new THREE.Clock();
document.addEventListener("keydown",(e)=>{
    switch(e.key.toLowerCase()){
        case "w":keys.w=1;break;
        case "a":keys.a=1;break;
        case "s":keys.s=1;break;
        case "d":keys.d=1;break;
        case " ":keys.space=1;e.preventDefault();break;
        case "control":keys.ctrl=1;break;
        case "tab":keys.tab=1;document.getElementById("leaderboard").style.display="block";e.preventDefault();break;
    }
});
document.addEventListener("keyup",(e)=>{
    switch(e.key.toLowerCase()){
        case "w":keys.w=0;break;
        case "a":keys.a=0;break;
        case "s":keys.s=0;break;
        case "d":keys.d=0;break;
        case " ":keys.space=0;break;
        case "control":keys.ctrl=0;break;
        case "tab":keys.tab=0;document.getElementById("leaderboard").style.display="none";break;
    }
});

// Camera
camera.position.set(0,50,50);

// Animation loop
function animate(){
    renderer.setAnimationLoop(()=>{
        const delta = clock.getDelta();
        playerMeshes.forEach(p=>{
            p.mesh.position.lerp(p.targetPos,0.1);
            p.label.position.copy(p.mesh.position).add(new THREE.Vector3(0,3,0));
        });

        if(!renderer.xr.isPresenting){
            const speed=moveSpeed*delta;
            const dir=new THREE.Vector3(Math.sin(0),0,Math.cos(0)).normalize();
            const right=new THREE.Vector3().crossVectors(dir,new THREE.Vector3(0,1,0)).normalize();
            if(keys.w) camera.position.addScaledVector(dir,-speed);
            if(keys.s) camera.position.addScaledVector(dir,speed);
            if(keys.a) camera.position.addScaledVector(right,speed);
            if(keys.d) camera.position.addScaledVector(right,-speed);
            if(keys.space) camera.position.y+=speed;
            if(keys.ctrl) camera.position.y-=speed;
        }

        renderer.render(scene,camera);
    });
}
animate();

window.addEventListener("resize",()=>{
    camera.aspect=window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>
