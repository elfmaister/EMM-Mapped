<!DOCTYPE html>
<html>
<head>
    <title>EMM 3D Map</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-family: Arial; z-index: 100; }
    </style>
</head>
<body>
    <div id="loading">Loading map...</div>
    <script>
        // Set up Three.js scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Sky blue background
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 20000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = false; // Disabled for simplicity
        document.body.appendChild(renderer.domElement);
        // Add lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(100, 200, 100);
        scene.add(directionalLight);
        // Basic floor as fallback
        const floorGeometry = new THREE.PlaneGeometry(20000, 20000);
        const floorMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 }); // Bright green
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);
        // Function to spawn/update a single realtime player indicator
        let realtimePlayerMesh = null;
        let realtimePlayerLabel = null;
        function spawnRealtimePlayerIndicator(data) {
            console.log('Spawning/updating realtime player with data:', data);
            if (!data || !data.name || data.x === undefined || data.y === undefined || data.z === undefined) {
                console.warn('Invalid realtime player data:', data);
                return;
            }
            // Coordinate transformation: GMod (x-forward, y-right, z-up) to Three.js (x-right, y-up, z-forward)
            // Offset from aligned spot: GMod (13231.96875, 13231.9921875, -10767.96875) -> Three.js (0, 45, 0)
            const offsetX = 13231.96875;
            const offsetY = 13231.9921875;
            const offsetZ = -10767.96875;
            const testHeight = 45; // Increased by 20 units for height
            const scaleFactor = 35; // GMod units to Three.js (1 foot â‰ˆ 16 Hammer units)
            const modelScale = 2.5; // Model scale factor
            const gmodX = data.x;
            const gmodY = data.y;
            const gmodZ = data.z;
            // Calculate base positions (pre-scale)
            const baseX = (gmodX - offsetX) / scaleFactor; // GMod X (forward) -> Three X (right)
            const baseY = (gmodZ - offsetZ) / scaleFactor; // GMod Z (up) -> base Three Y (up)
            const baseZ = -(gmodY - offsetY) / scaleFactor; // GMod Y (right) -> Three Z (forward, flipped)
            // Apply model scale
            const posX = baseX * modelScale;
            const posY = baseY * modelScale + testHeight + 1; // Slight offset above surface
            const posZ = baseZ * modelScale;
            console.log('Transformed position:', {posX, posY, posZ});
            // Create or update player mesh
            if (!realtimePlayerMesh) {
                const playerGeometry = new THREE.CylinderGeometry(1, 1, 2, 8); // Radius 1 (2 units wide), height 2
                const playerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Bright red
                realtimePlayerMesh = new THREE.Mesh(playerGeometry, playerMaterial);
                scene.add(realtimePlayerMesh);
                // Create name label
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                context.fillStyle = 'rgba(0, 0, 0, 0.7)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                context.fillStyle = 'white';
                context.font = 'bold 20px Arial';
                context.fillText(data.name, 10, 35);
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                realtimePlayerLabel = new THREE.Sprite(spriteMaterial);
                realtimePlayerLabel.scale.set(20, 5, 1); // Reasonable label size
                scene.add(realtimePlayerLabel);
                console.log('Created realtime player mesh and label for:', data.name);
            }
            // Update position
            realtimePlayerMesh.position.set(posX, posY, posZ);
            realtimePlayerLabel.position.set(posX, posY + 3, posZ); // Above the cylinder
        }
        // Load gm_bigcity.gltf
        const loader = new THREE.GLTFLoader();
        let mapLoaded = false;
        loader.load(
            '/gm_bigcity/scene.gltf',
            (gltf) => {
                console.log('Map loaded successfully');
                scene.add(gltf.scene);
                gltf.scene.scale.set(2.5, 2.5, 2.5); // Scale up model by 2.5x
                gltf.scene.position.set(0, 15, 0);
                mapLoaded = true;
                document.getElementById('loading').style.display = 'none';
                // Initialize realtime player after map loads
                initRealtimePlayer();
            },
            (progress) => {
                console.log('Loading progress:', (progress.loaded / progress.total * 100) + '%');
            },
            (error) => {
                console.error('Error loading GLTF:', error);
                document.getElementById('loading').innerHTML = 'Failed to load map. Using fallback floor.';
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                    // Initialize realtime player even if map fails
                    initRealtimePlayer();
                }, 3000);
            }
        );
        // Initialize WebSocket for realtime player
        function initRealtimePlayer() {
            const socket = new WebSocket('wss://emm-mapped.onrender.com/data');
            socket.onopen = () => {
                console.log('WebSocket connected for realtime player');
            };
            socket.onmessage = (event) => {
                try {
                    const message = JSON.parse(event.data);
                    if (message.players) {
                        // Assume single player for now; take first
                        const playerData = message.players[0] || message.players;
                        spawnRealtimePlayerIndicator(playerData);
                    }
                } catch (e) {
                    console.error('Error parsing WebSocket message:', e);
                }
            };
            socket.onclose = () => {
                console.log('WebSocket disconnected');
            };
            socket.onerror = (error) => {
                console.error('WebSocket error:', error);
            };
        }
        // WASD free camera controls with Space and Ctrl
        const moveSpeed = 5;
        const rotateSpeed = 0.002;
        const keys = { w: false, a: false, s: false, d: false, space: false, ctrl: false };
        let mouseDown = false;
        let prevMouseX = 0;
        document.addEventListener('keydown', (event) => {
            switch (event.key.toLowerCase()) {
                case 'w': keys.w = true; break;
                case 'a': keys.a = true; break;
                case 's': keys.s = true; break;
                case 'd': keys.d = true; break;
                case ' ': keys.space = true; break;
                case 'control': keys.ctrl = true; break;
            }
        });
        document.addEventListener('keyup', (event) => {
            switch (event.key.toLowerCase()) {
                case 'w': keys.w = false; break;
                case 'a': keys.a = false; break;
                case 's': keys.s = false; break;
                case 'd': keys.d = false; break;
                case ' ': keys.space = false; break;
                case 'control': keys.ctrl = false; break;
            }
        });
        document.addEventListener('mousedown', (event) => {
            if (event.button === 2) { // Right-click
                mouseDown = true;
                prevMouseX = event.clientX;
            }
        });
        document.addEventListener('mouseup', (event) => {
            if (event.button === 2) mouseDown = false;
        });
        document.addEventListener('mousemove', (event) => {
            if (mouseDown) {
                const deltaX = event.clientX - prevMouseX;
                camera.rotation.y -= deltaX * rotateSpeed;
                prevMouseX = event.clientX;
            }
        });
        // Prevent right-click context menu
        document.addEventListener('contextmenu', (event) => event.preventDefault());
        // Camera setup
        camera.position.set(0, 50, 50);
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            // Update camera position based on WASD, Space, and Ctrl input
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            direction.y = 0; // Keep horizontal movement
            direction.normalize();
            const right = new THREE.Vector3();
            right.crossVectors(direction, new THREE.Vector3(0, 1, 0)).normalize();
            if (keys.w) camera.position.addScaledVector(direction, moveSpeed);
            if (keys.s) camera.position.addScaledVector(direction, -moveSpeed);
            if (keys.a) camera.position.addScaledVector(right, -moveSpeed);
            if (keys.d) camera.position.addScaledVector(right, moveSpeed);
            if (keys.space) camera.position.y += moveSpeed;
            if (keys.ctrl) camera.position.y -= moveSpeed;
            renderer.render(scene, camera);
        }
        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        // Start everything
        animate();
    </script>
</body>
</html>
