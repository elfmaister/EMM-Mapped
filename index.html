<!DOCTYPE html>
<html>
<head>
    <title>EMM 3D Map</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/webxr/VRButton.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/webxr/XRControllerModelFactory.js"></script>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #loading {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white; font-family: Arial; z-index: 100;
        }
        #leaderboard {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8); color: white;
            padding: 20px; border-radius: 8px; font-family: Arial;
            z-index: 200; display: none;
            max-height: 80vh; overflow-y: auto;
        }
        #leaderboard h2 { margin: 0 0 10px; text-align: center; }
        #leaderboard table { width: 100%; border-collapse: collapse; }
        #leaderboard th, #leaderboard td {
            padding: 8px; text-align: left; border-bottom: 1px solid #555;
        }
    </style>
</head>
<body>
    <div id="loading">Loading map...</div>
    <div id="leaderboard">
        <h2>Fastest Velocities</h2>
        <table>
            <thead><tr><th>Player</th><th>Max Velocity (u/s)</th></tr></thead>
            <tbody id="leaderboard-body"></tbody>
        </table>
    </div>
    <script>
        // Check WebXR support
        if (navigator.xr) {
            navigator.xr.isSessionSupported('immersive-vr').then(supported => {
                console.log('WebXR immersive-vr supported:', supported);
                if (!supported) {
                    console.warn('WebXR immersive-vr not supported. Check browser settings or version.');
                }
            }).catch(err => {
                console.error('WebXR support check failed:', err);
            });
        } else {
            console.warn('WebXR not available in this browser. Ensure HTTPS and latest browser version.');
        }
        // Shared transform constants
        const offsetX = 6498.061;
        const offsetY = -7027.718;
        const offsetZ = -10647.092;
        const testHeight = 45;
        const scaleFactor = 39.269;
        const modelScale = 2.5;
        const latestPlayerData = {};
        let yaw = 0, pitch = 0;
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 20000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);
        // Add VR button with error handling
        if (typeof VRButton !== 'undefined') {
            document.body.appendChild(VRButton.createButton(renderer));
        } else {
            console.warn('VRButton not available, skipping VR initialization');
        }
        // VR controllers
        let controller1, controller2, controllerGrip1, controllerGrip2;
        if (typeof XRControllerModelFactory !== 'undefined') {
            controller1 = renderer.xr.getController(0);
            controller2 = renderer.xr.getController(1);
            scene.add(controller1);
            scene.add(controller2);
            const controllerModelFactory = new XRControllerModelFactory();
            controllerGrip1 = renderer.xr.getControllerGrip(0);
            controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
            scene.add(controllerGrip1);
            controllerGrip2 = renderer.xr.getControllerGrip(1);
            controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
            scene.add(controllerGrip2);
        } else {
            console.warn('XRControllerModelFactory not available, skipping controller setup');
        }
        // VR locomotion variables
        let vrMoveSpeed = 50;
        let isVRActive = false;
        // VR session events
        renderer.xr.addEventListener('sessionstart', () => {
            isVRActive = true;
            camera.position.set(0, 50, 50);
            document.getElementById('leaderboard').style.display = 'none';
        });
        renderer.xr.addEventListener('sessionend', () => {
            isVRActive = false;
            camera.position.set(0, 50, 50);
        });
        // VR movement
        function handleVRMovement(delta) {
            if (!isVRActive) return;
            const session = renderer.xr.getSession();
            if (!session) return;
            const inputSources = session.inputSources;
            let moveDir = new THREE.Vector3(0, 0, 0);
            inputSources.forEach((input) => {
                if (input.gamepad && input.gamepad.axes.length >= 2) {
                    const [xAxis, yAxis] = input.gamepad.axes;
                    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                    moveDir.add(forward.multiplyScalar(-yAxis));
                    moveDir.add(right.multiplyScalar(xAxis));
                }
            });
            moveDir.y = 0;
            if (moveDir.length() > 0) {
                moveDir.normalize().multiplyScalar(vrMoveSpeed * delta);
                camera.position.add(moveDir);
            }
        }
        // Lights
        scene.add(new THREE.AmbientLight(0xffffff, 1.0));
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(100,200,100);
        scene.add(dirLight);
        // Players
        const playerGeometry = new THREE.CylinderGeometry(1,1,2,8);
        const playerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const playerMeshes = new Map();
        const maxVelocities = new Map();
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let followTarget = null;
        // Leaderboard UI
        function updateLeaderboard() {
            const tbody = document.getElementById("leaderboard-body");
            tbody.innerHTML = "";
            const sorted = Array.from(maxVelocities.entries()).sort((a,b)=>b[1]-a[1]);
            sorted.forEach(([name,vel],i)=>{
                if(name==="unconnected") return;
                let medal = i===0?"ðŸ¥‡ ":i===1?"ðŸ¥ˆ ":i===2?"ðŸ¥‰ ":"";
                const row = document.createElement("tr");
                row.innerHTML = `<td>${medal}${name}</td><td>${vel.toFixed(2)}</td>`;
                tbody.appendChild(row);
            });
        }
        // Spawn or update a player
        function spawnRealtimePlayerIndicator(data) {
            if (!data || !data.name) return;
            const baseX = (data.x - offsetX) / scaleFactor;
            const baseY = (data.z - offsetZ) / scaleFactor;
            const baseZ = -(data.y - offsetY) / scaleFactor;
            const posX = baseX * modelScale;
            const posY = baseY * modelScale + testHeight + 1;
            const posZ = baseZ * modelScale;
            if (data.vel !== undefined) {
                const adjustedVel = data.vel / 10;
                const currentMax = maxVelocities.get(data.name) || 0;
                if (adjustedVel > currentMax) {
                    maxVelocities.set(data.name, adjustedVel);
                    localStorage.setItem("maxVelocities", JSON.stringify(Object.fromEntries(maxVelocities)));
                    updateLeaderboard();
                }
            }
            if (!playerMeshes.has(data.name)) {
                const mesh = new THREE.Mesh(playerGeometry, playerMaterial);
                scene.add(mesh);
                const canvas = document.createElement("canvas");
                canvas.width = 256; canvas.height = 64;
                const ctx = canvas.getContext("2d");
                ctx.fillStyle = "rgba(0,0,0,0.7)";
                ctx.fillRect(0,0,canvas.width,canvas.height);
                ctx.fillStyle="white";
                ctx.font="bold 20px Arial";
                ctx.fillText(data.name,10,35);
                const label = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas) }));
                label.scale.set(20,5,1);
                scene.add(label);
                playerMeshes.set(data.name, { mesh, label, targetPos: new THREE.Vector3() });
            }
            const player = playerMeshes.get(data.name);
            player.targetPos.set(posX,posY,posZ);
            player.label.position.set(posX,posY+3,posZ);
            latestPlayerData[data.name] = data;
        }
        // Load map with enhanced logging
        const loader = typeof THREE.GLTFLoader !== 'undefined' ? new THREE.GLTFLoader() : null;
        async function loadMap() {
            if (!loader) {
                console.error('GLTFLoader not available, skipping map load');
                document.getElementById("loading").innerText = 'Failed to load map: GLTFLoader unavailable';
                setTimeout(() => {
                    document.getElementById("loading").style.display = "none";
                    console.log('Proceeding to WebSocket initialization');
                    initRealtimePlayer();
                }, 10000);
                return;
            }
            try {
                console.log('Attempting to load /gm_bigcity/scene.gltf');
                const gltf = await new Promise((res, rej) => {
                    loader.load(
                        '/gm_bigcity/scene.gltf',
                        (gltf) => {
                            console.log('glTF loaded successfully');
                            res(gltf);
                        },
                        (p) => {
                            const percent = (p.loaded / p.total * 100).toFixed(2);
                            console.log(`Loading progress: ${percent}% (${p.loaded}/${p.total} bytes)`);
                            document.getElementById("loading").innerText = `Loading map... ${percent}%`;
                        },
                        (err) => {
                            console.error('glTF load error:', err);
                            rej(err);
                        }
                    );
                });
                scene.add(gltf.scene);
                gltf.scene.scale.set(2.5, 2.5, 2.5);
                gltf.scene.position.set(0, 15, 0);
                console.log('Map added to scene');
                document.getElementById("loading").style.display = "none";
                initRealtimePlayer();
            } catch (err) {
                console.error('Map loading failed:', err);
                let errorMsg = err.message || 'Unknown error';
                if (err.message.includes('fetch')) errorMsg = 'Network error: Failed to fetch glTF';
                document.getElementById("loading").innerText = `Failed to load map: ${errorMsg}`;
                setTimeout(() => {
                    document.getElementById("loading").style.display = "none";
                    console.log('Proceeding to WebSocket initialization');
                    initRealtimePlayer();
                }, 10000);
            }
        }
        loadMap();
        // WebSocket connection
        function initRealtimePlayer() {
            console.log('Initializing WebSocket connection');
            const socket = new WebSocket("wss://emm-mapped.onrender.com/data");
            socket.onopen = () => console.log("WebSocket connected");
            socket.onmessage = (event) => {
                try {
                    const msg = JSON.parse(event.data);
                    if (msg.players) {
                        const current = new Set();
                        msg.players.forEach(p => {
                            spawnRealtimePlayerIndicator(p);
                            current.add(p.name);
                        });
                        playerMeshes.forEach((pl, name) => {
                            if (!current.has(name)) {
                                scene.remove(pl.mesh);
                                scene.remove(pl.label);
                                playerMeshes.delete(name);
                                updateLeaderboard();
                            }
                        });
                    }
                } catch (e) {
                    console.error("Bad WS msg:", e);
                }
            };
            socket.onclose = () => console.log("WebSocket closed");
            socket.onerror = (e) => console.error("WebSocket error:", e);
        }
        // Freecam controls
        const moveSpeed = 50;
        const keys = {w:0,a:0,s:0,d:0,space:0,ctrl:0,tab:0};
        const clock = new THREE.Clock();
        document.addEventListener("keydown", (e) => {
            switch(e.key.toLowerCase()){
                case "w": keys.w = 1; break;
                case "a": keys.a = 1; break;
                case "s": keys.s = 1; break;
                case "d": keys.d = 1; break;
                case " ": keys.space = 1; e.preventDefault(); break;
                case "control": keys.ctrl = 1; break;
                case "tab": keys.tab = 1; document.getElementById("leaderboard").style.display = "block"; e.preventDefault(); break;
            }
        });
        document.addEventListener("keyup", (e) => {
            switch(e.key.toLowerCase()){
                case "w": keys.w = 0; break;
                case "a": keys.a = 0; break;
                case "s": keys.s = 0; break;
                case "d": keys.d = 0; break;
                case " ": keys.space = 0; break;
                case "control": keys.ctrl = 0; break;
                case "tab": keys.tab = 0; document.getElementById("leaderboard").style.display = "none"; break;
            }
        });
        // Click to follow
        document.addEventListener("click", (e) => {
            if (isVRActive) return;
            renderer.domElement.requestPointerLock();
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const meshes = Array.from(playerMeshes.values()).map(p => p.mesh);
            const hits = raycaster.intersectObjects(meshes);
            if (hits.length > 0) {
                const clicked = hits[0].object;
                for (let [name, pl] of playerMeshes.entries()) {
                    if (pl.mesh === clicked) {
                        followTarget = name;
                        console.log("Following", name);
                        pl.mesh.visible = false;
                        pl.label.visible = false;
                    }
                }
            } else {
                followTarget = null;
                playerMeshes.forEach(p => {
                    p.mesh.visible = true;
                    p.label.visible = true;
                });
            }
        });
        // Camera
        camera.position.set(0, 50, 50);
        // Main loop
        function animate() {
            renderer.setAnimationLoop((time) => {
                const delta = clock.getDelta();
                playerMeshes.forEach(p => {
                    p.mesh.position.lerp(p.targetPos, 0.1);
                    p.label.position.copy(p.mesh.position).add(new THREE.Vector3(0, 3, 0));
                });
                if (!isVRActive) {
                    if (!followTarget) {
                        const speed = moveSpeed * delta;
                        const dir = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw)).normalize();
                        const right = new THREE.Vector3().crossVectors(dir, new THREE.Vector3(0, 1, 0)).normalize();
                        if (keys.w) camera.position.addScaledVector(dir, speed);
                        if (keys.s) camera.position.addScaledVector(dir, -speed);
                        if (keys.a) camera.position.addScaledVector(right, -speed);
                        if (keys.d) camera.position.addScaledVector(right, speed);
                        if (keys.space) camera.position.y += speed;
                        if (keys.ctrl) camera.position.y -= speed;
                        camera.rotation.set(pitch, yaw, 0, "YXZ");
                    }
                    if (followTarget && playerMeshes.has(followTarget)) {
                        const playerData = latestPlayerData[followTarget];
                        if (playerData) {
                            const baseX = (playerData.x - offsetX) / scaleFactor;
                            const baseY = (playerData.z - offsetZ) / scaleFactor;
                            const baseZ = -(playerData.y - offsetY) / scaleFactor;
                            const posX = baseX * modelScale;
                            const posY = baseY * modelScale + testHeight + 3;
                            const posZ = baseZ * modelScale;
                            camera.position.set(posX, posY, posZ);
                            const pch = THREE.MathUtils.degToRad(-playerData.pitch || 0);
                            const yw = THREE.MathUtils.degToRad(playerData.yaw || 0);
                            camera.quaternion.setFromEuler(new THREE.Euler(pch, yw - Math.PI / 2, 0, "YXZ"));
                        }
                    }
                } else {
                    handleVRMovement(delta);
                    if (followTarget && playerMeshes.has(followTarget)) {
                        const playerData = latestPlayerData[followTarget];
                        if (playerData) {
                            const baseX = (data.x - offsetX) / scaleFactor;
                            const baseY = (data.z - offsetZ) / scaleFactor;
                            const baseZ = -(data.y - offsetY) / scaleFactor;
                            const posX = baseX * modelScale;
                            const posY = baseY * modelScale + testHeight + 3;
                            const posZ = baseZ * modelScale;
                            camera.position.set(posX, posY, posZ);
                            const pch = THREE.MathUtils.degToRad(-playerData.pitch || 0);
                            const yw = THREE.MathUtils.degToRad(playerData.yaw || 0);
                            camera.quaternion.setFromEuler(new THREE.Euler(pch, yw - Math.PI / 2, 0, "YXZ"));
                        }
                    }
                }
                renderer.render(scene, camera);
            });
        }
        animate();
        window.addEventListener("resize", () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
