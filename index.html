<!DOCTYPE html>
<html>
<head>
    <title>EMM 3D Map</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/vr/VRButton.js"></script>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #loading {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white; font-family: Arial; z-index: 100;
        }
        #leaderboard {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8); color: white;
            padding: 20px; border-radius: 8px; font-family: Arial;
            z-index: 200; display: none;
            max-height: 80vh; overflow-y: auto;
        }
        #leaderboard h2 { margin: 0 0 10px; text-align: center; }
        #leaderboard table { width: 100%; border-collapse: collapse; }
        #leaderboard th, #leaderboard td {
            padding: 8px; text-align: left; border-bottom: 1px solid #555;
        }
    </style>
</head>
<body>
    <div id="loading">Loading map...</div>
    <div id="leaderboard">
        <h2>Fastest Velocities</h2>
        <table>
            <thead><tr><th>Player</th><th>Max Velocity (u/s)</th></tr></thead>
            <tbody id="leaderboard-body"></tbody>
        </table>
    </div>

    <script>
    // ------------------------------
    // Constants & Globals
    // ------------------------------
    const offsetX = 6498.061;
    const offsetY = -7027.718;
    const offsetZ = -10647.092;
    const testHeight = 45;
    const scaleFactor = 39.269;
    const modelScale = 2.5;

    const latestPlayerData = {};
    const playerMeshes = new Map();
    const maxVelocities = new Map();

    let yaw = 0, pitch = 0; // desktop freecam rotation
    let followTarget = null; // click-to-follow (optional)

    // ------------------------------
    // Scene, Camera, Renderer
    // ------------------------------
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 20000);
    // Spawn above map center for VR
    camera.position.set(0, 200, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.xr.enabled = true; // enable WebXR
    document.body.appendChild(renderer.domElement);
    document.body.appendChild(VRButton.createButton(renderer)); // add VR button

    // ------------------------------
    // Lights
    // ------------------------------
    scene.add(new THREE.AmbientLight(0xffffff, 1.0));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
    dirLight.position.set(100,200,100);
    scene.add(dirLight);

    // ------------------------------
    // Player indicators
    // ------------------------------
    const playerGeometry = new THREE.CylinderGeometry(1,1,2,8);
    const playerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });

    function spawnRealtimePlayerIndicator(data){
        if(!data || !data.name) return;

        const baseX = (data.x - offsetX)/scaleFactor;
        const baseY = (data.z - offsetZ)/scaleFactor;
        const baseZ = -(data.y - offsetY)/scaleFactor;
        const posX = baseX * modelScale;
        const posY = baseY * modelScale + testHeight + 1;
        const posZ = baseZ * modelScale;

        // Max velocity
        if(data.vel !== undefined){
            const adjustedVel = data.vel/10;
            const currentMax = maxVelocities.get(data.name)||0;
            if(adjustedVel > currentMax){
                maxVelocities.set(data.name, adjustedVel);
                localStorage.setItem("maxVelocities", JSON.stringify(Object.fromEntries(maxVelocities)));
                updateLeaderboard();
            }
        }

        if(!playerMeshes.has(data.name)){
            const mesh = new THREE.Mesh(playerGeometry, playerMaterial);
            scene.add(mesh);

            const canvas = document.createElement("canvas");
            canvas.width=256; canvas.height=64;
            const ctx = canvas.getContext("2d");
            ctx.fillStyle="rgba(0,0,0,0.7)"; ctx.fillRect(0,0,canvas.width,canvas.height);
            ctx.fillStyle="white"; ctx.font="bold 20px Arial";
            ctx.fillText(data.name,10,35);
            const label = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas) }));
            label.scale.set(20,5,1);
            scene.add(label);

            playerMeshes.set(data.name, {mesh,label,targetPos:new THREE.Vector3()});
        }

        const player = playerMeshes.get(data.name);
        player.targetPos.set(posX,posY,posZ);
        player.label.position.set(posX,posY+3,posZ);

        latestPlayerData[data.name] = data;
    }

    function updateLeaderboard(){
        const tbody = document.getElementById("leaderboard-body");
        tbody.innerHTML = "";
        const sorted = Array.from(maxVelocities.entries()).sort((a,b)=>b[1]-a[1]);
        sorted.forEach(([name,vel],i)=>{
            if(name==="unconnected") return;
            let medal = i===0?"ðŸ¥‡ ":i===1?"ðŸ¥ˆ ":i===2?"ðŸ¥‰ ":"";
            const row = document.createElement("tr");
            row.innerHTML=`<td>${medal}${name}</td><td>${vel.toFixed(2)}</td>`;
            tbody.appendChild(row);
        });
    }

    // ------------------------------
    // Load Map
    // ------------------------------
    const loader = new THREE.GLTFLoader();
    async function loadMap(){
        try{
            const gltf = await new Promise((res,rej)=>{
                loader.load("/gm_bigcity/scene.gltf",res,(p)=>{
                    const percent = (p.loaded/p.total*100).toFixed(2);
                    document.getElementById("loading").innerText=`Loading map... ${percent}%`;
                },rej);
            });
            scene.add(gltf.scene);
            gltf.scene.scale.set(2.5,2.5,2.5);
            gltf.scene.position.set(0,0,0); // map at origin
            document.getElementById("loading").style.display="none";
            initRealtimePlayer();
        } catch(err){
            console.error("Error loading map:",err);
            document.getElementById("loading").innerText="Failed to load map.";
            setTimeout(()=>{document.getElementById("loading").style.display="none"; initRealtimePlayer();},3000);
        }
    }
    loadMap();

    // ------------------------------
    // WebSocket for player data
    // ------------------------------
    function initRealtimePlayer(){
        const socket = new WebSocket("wss://emm-mapped.onrender.com/data");
        socket.onopen = ()=>console.log("WebSocket connected");
        socket.onmessage = (event)=>{
            try{
                const msg = JSON.parse(event.data);
                if(msg.players){
                    const current = new Set();
                    msg.players.forEach(p=>{
                        spawnRealtimePlayerIndicator(p);
                        current.add(p.name);
                    });
                    playerMeshes.forEach((pl,name)=>{
                        if(!current.has(name)){
                            scene.remove(pl.mesh);
                            scene.remove(pl.label);
                            playerMeshes.delete(name);
                            updateLeaderboard();
                        }
                    });
                }
            }catch(e){console.error("Bad WS msg:",e);}
        };
        socket.onclose = ()=>console.log("WebSocket closed");
        socket.onerror = (e)=>console.error("WebSocket error:",e);
    }

    // ------------------------------
    // Freecam controls
    // ------------------------------
    const moveSpeed = 50;
    const keys = {w:0,a:0,s:0,d:0,space:0,ctrl:0,tab:0};
    const clock = new THREE.Clock();

    document.addEventListener("keydown",(e)=>{
        switch(e.key.toLowerCase()){
            case "w": keys.w=1; break;
            case "a": keys.a=1; break;
            case "s": keys.s=1; break;
            case "d": keys.d=1; break;
            case " ": keys.space=1; e.preventDefault(); break;
            case "control": keys.ctrl=1; break;
            case "tab": keys.tab=1; document.getElementById("leaderboard").style.display="block"; e.preventDefault(); break;
        }
    });
    document.addEventListener("keyup",(e)=>{
        switch(e.key.toLowerCase()){
            case "w": keys.w=0; break;
            case "a": keys.a=0; break;
            case "s": keys.s=0; break;
            case "d": keys.d=0; break;
            case " ": keys.space=0; break;
            case "control": keys.ctrl=0; break;
            case "tab": keys.tab=0; document.getElementById("leaderboard").style.display="none"; break;
        }
    });

    // ------------------------------
    // Animation & VR Loop
    // ------------------------------
    renderer.setAnimationLoop(()=>{
        const delta = clock.getDelta();

        // Lerp player positions
        playerMeshes.forEach(p=>{
            p.mesh.position.lerp(p.targetPos,0.1);
            p.label.position.copy(p.mesh.position).add(new THREE.Vector3(0,3,0));
        });

        // Desktop freecam movement
        const dir = new THREE.Vector3(Math.sin(yaw),0,Math.cos(yaw)).normalize();
        const right = new THREE.Vector3().crossVectors(dir,new THREE.Vector3(0,1,0)).normalize();
        const speed = moveSpeed*delta;

        if(!renderer.xr.isPresenting){
            if(keys.w) camera.position.addScaledVector(dir,speed);
            if(keys.s) camera.position.addScaledVector(dir,-speed);
            if(keys.a) camera.position.addScaledVector(right,-speed);
            if(keys.d) camera.position.addScaledVector(right,speed);
            if(keys.space) camera.position.y += speed;
            if(keys.ctrl) camera.position.y -= speed;
            camera.rotation.set(pitch,yaw,0,"YXZ");
        }

        renderer.render(scene,camera);
    });

    // ------------------------------
    // Window resize
    // ------------------------------
    window.addEventListener("resize",()=>{
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth,window.innerHeight);
    });
    </script>
</body>
</html>
