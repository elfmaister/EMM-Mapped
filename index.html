<!DOCTYPE html>
<html>
<head>
    <title>EMM 3D Map (VR Freecam)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="/scripts/VRButton.js"></script> <!-- local VRButton UMD -->
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #loading {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white; font-family: Arial; z-index: 100;
        }
        #leaderboard {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8); color: white;
            padding: 20px; border-radius: 8px; font-family: Arial;
            z-index: 200; display: none;
            max-height: 80vh; overflow-y: auto;
        }
        #leaderboard h2 { margin: 0 0 10px; text-align: center; }
        #leaderboard table { width: 100%; border-collapse: collapse; }
        #leaderboard th, #leaderboard td {
            padding: 8px; text-align: left; border-bottom: 1px solid #555;
        }
    </style>
</head>
<body>
<div id="loading">Loading map...</div>
<div id="leaderboard">
    <h2>Fastest Velocities</h2>
    <table>
        <thead><tr><th>Player</th><th>Max Velocity (u/s)</th></tr></thead>
        <tbody id="leaderboard-body"></tbody>
    </table>
</div>

<script>
    // Shared constants
    const offsetX = 6498.061, offsetY = -7027.718, offsetZ = -10647.092;
    const testHeight = 45, scaleFactor = 39.269, modelScale = 2.5;
    const latestPlayerData = {};
    let yaw = 0, pitch = 0;

    // Scene & renderer
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 20000);
    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);
    document.body.appendChild(VRButton.createButton(renderer));

    // Lights
    scene.add(new THREE.AmbientLight(0xffffff, 1.0));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
    dirLight.position.set(100,200,100);
    scene.add(dirLight);

    // Players
    const playerGeometry = new THREE.CylinderGeometry(1,1,2,8);
    const playerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    const playerMeshes = new Map();
    const maxVelocities = new Map();
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let followTarget = null;

    // Leaderboard
    function updateLeaderboard() {
        const tbody = document.getElementById("leaderboard-body");
        tbody.innerHTML = "";
        Array.from(maxVelocities.entries())
            .sort((a,b)=>b[1]-a[1])
            .forEach(([name,vel],i)=>{
                if(name==="unconnected") return;
                let medal = i===0?"ðŸ¥‡ ":i===1?"ðŸ¥ˆ ":i===2?"ðŸ¥‰ ":"";
                const row = document.createElement("tr");
                row.innerHTML = `<td>${medal}${name}</td><td>${vel.toFixed(2)}</td>`;
                tbody.appendChild(row);
            });
    }

    function spawnRealtimePlayerIndicator(data){
        if(!data || !data.name) return;

        const baseX = (data.x - offsetX)/scaleFactor;
        const baseY = (data.z - offsetZ)/scaleFactor;
        const baseZ = -(data.y - offsetY)/scaleFactor;
        const posX = baseX*modelScale;
        const posY = baseY*modelScale + testHeight + 1;
        const posZ = baseZ*modelScale;

        if(data.vel !== undefined){
            const adjustedVel = data.vel/10;
            const currentMax = maxVelocities.get(data.name) || 0;
            if(adjustedVel>currentMax){
                maxVelocities.set(data.name, adjustedVel);
                localStorage.setItem("maxVelocities", JSON.stringify(Object.fromEntries(maxVelocities)));
                updateLeaderboard();
            }
        }

        if(!playerMeshes.has(data.name)){
            const mesh = new THREE.Mesh(playerGeometry, playerMaterial);
            scene.add(mesh);

            const canvas = document.createElement("canvas");
            canvas.width=256; canvas.height=64;
            const ctx=canvas.getContext("2d");
            ctx.fillStyle="rgba(0,0,0,0.7)";
            ctx.fillRect(0,0,canvas.width,canvas.height);
            ctx.fillStyle="white";
            ctx.font="bold 20px Arial";
            ctx.fillText(data.name,10,35);
            const label = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas) }));
            label.scale.set(20,5,1);
            scene.add(label);

            playerMeshes.set(data.name,{mesh,label,targetPos:new THREE.Vector3()});
        }

        const player = playerMeshes.get(data.name);
        player.targetPos.set(posX,posY,posZ);
        player.label.position.set(posX,posY+3,posZ);
        latestPlayerData[data.name]=data;
    }

    // Load map
    const loader = new THREE.GLTFLoader();
    loader.load("/gm_bigcity/scene.gltf",
        gltf=>{
            scene.add(gltf.scene);
            gltf.scene.scale.set(2.5,2.5,2.5);
            gltf.scene.position.set(0,15,0);
            document.getElementById("loading").style.display="none";
            initRealtimePlayer();
        },
        xhr=>{
            const percent=(xhr.loaded/xhr.total*100).toFixed(2);
            document.getElementById("loading").innerText=`Loading map... ${percent}%`;
        },
        err=>{
            console.error("Failed to load map",err);
            document.getElementById("loading").innerText="Failed to load map.";
            setTimeout(()=>document.getElementById("loading").style.display="none",3000);
        }
    );

    // WebSocket
    function initRealtimePlayer(){
        const socket=new WebSocket("wss://emm-mapped.onrender.com/data");
        socket.onopen=()=>console.log("WebSocket connected");
        socket.onmessage=(event)=>{
            try{
                const msg=JSON.parse(event.data);
                if(msg.players){
                    const current=new Set();
                    msg.players.forEach(p=>{ spawnRealtimePlayerIndicator(p); current.add(p.name); });
                    playerMeshes.forEach((pl,name)=>{
                        if(!current.has(name)){
                            scene.remove(pl.mesh); scene.remove(pl.label);
                            playerMeshes.delete(name);
                            updateLeaderboard();
                        }
                    });
                }
            }catch(e){console.error("Bad WS msg",e);}
        };
        socket.onclose=()=>console.log("WebSocket closed");
        socket.onerror=e=>console.error("WebSocket error",e);
    }

    // Freecam keyboard controls
    const moveSpeed=50;
    const keys={w:0,a:0,s:0,d:0,space:0,ctrl:0,tab:0};
    const clock=new THREE.Clock();
    document.addEventListener("keydown",e=>{
        switch(e.key.toLowerCase()){
            case "w": keys.w=1; break;
            case "a": keys.a=1; break;
            case "s": keys.s=1; break;
            case "d": keys.d=1; break;
            case " ": keys.space=1; e.preventDefault(); break;
            case "control": keys.ctrl=1; break;
            case "tab": keys.tab=1; document.getElementById("leaderboard").style.display="block"; e.preventDefault(); break;
        }
    });
    document.addEventListener("keyup",e=>{
        switch(e.key.toLowerCase()){
            case "w": keys.w=0; break;
            case "a": keys.a=0; break;
            case "s": keys.s=0; break;
            case "d": keys.d=0; break;
            case " ": keys.space=0; break;
            case "control": keys.ctrl=0; break;
            case "tab": keys.tab=0; document.getElementById("leaderboard").style.display="none"; break;
        }
    });

    // Camera
    camera.position.set(0,50,50);

    // Animation loop
    function animate(){
        renderer.setAnimationLoop(()=>{
            const delta=clock.getDelta();

            // Lerp players
            playerMeshes.forEach(p=>{
                p.mesh.position.lerp(p.targetPos,0.1);
                p.label.position.copy(p.mesh.position).add(new THREE.Vector3(0,3,0));
            });

            if(renderer.xr.isPresenting){
                // âœ… VR freecam movement
                const session = renderer.xr.getSession();
                if(session){
                    session.inputSources.forEach(input=>{
                        if(input.gamepad){
                            const axes = input.gamepad.axes;
                            const speed = 1.5; // adjust VR speed
                            const camDir = new THREE.Vector3();
                            camera.getWorldDirection(camDir);
                            camDir.y=0;
                            camDir.normalize();
                            const right = new THREE.Vector3().crossVectors(camDir,new THREE.Vector3(0,1,0)).normalize();
                            // axes[2]=X, axes[3]=Y thumbstick (may vary per controller)
                            camera.position.addScaledVector(camDir, -axes[3]*speed);
                            camera.position.addScaledVector(right, axes[2]*speed);
                            // Up/down with left thumbstick Y (axes[1])
                            camera.position.y += (-axes[1])*speed;
                        }
                    });
                }
            } else {
                // Non-VR freecam
                const speed=moveSpeed*delta;
                const dir=new THREE.Vector3(Math.sin(yaw),0,Math.cos(yaw)).normalize();
                const right=new THREE.Vector3().crossVectors(dir,new THREE.Vector3(0,1,0)).normalize();
                if(keys.w) camera.position.addScaledVector(dir,speed);
                if(keys.s) camera.position.addScaledVector(dir,-speed);
                if(keys.a) camera.position.addScaledVector(right,-speed);
                if(keys.d) camera.position.addScaledVector(right,speed);
                if(keys.space) camera.position.y+=speed;
                if(keys.ctrl) camera.position.y-=speed;
                camera.rotation.set(pitch,yaw,0,"YXZ");
            }

            renderer.render(scene,camera);
        });
    }
    animate();

    window.addEventListener("resize",()=>{
        camera.aspect=window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth,window.innerHeight);
    });
</script>
</body>
</html>
