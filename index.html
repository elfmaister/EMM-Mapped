<!DOCTYPE html>
<html>
<head>
    <title>EMM 3D Map with VR Support</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/webxr/VRButton.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/webxr/XRControllerModelFactory.js"></script>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #loading {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white; font-family: Arial; z-index: 100;
        }
        #leaderboard {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8); color: white;
            padding: 20px; border-radius: 8px; font-family: Arial;
            z-index: 200; display: none;
            max-height: 80vh; overflow-y: auto;
        }
        #leaderboard h2 { margin: 0 0 10px; text-align: center; }
        #leaderboard table { width: 100%; border-collapse: collapse; }
        #leaderboard th, #leaderboard td {
            padding: 8px; text-align: left; border-bottom: 1px solid #555;
        }
    </style>
</head>
<body>
    <div id="loading">Loading map...</div>
    <div id="leaderboard">
        <h2>Fastest Velocities</h2>
        <table>
            <thead><tr><th>Player</th><th>Max Velocity (u/s)</th></tr></thead>
            <tbody id="leaderboard-body"></tbody>
        </table>
    </div>

    <script>
        // Shared transform constants
        const offsetX = 6498.061;
        const offsetY = -7027.718;
        const offsetZ = -10647.092;
        const testHeight = 45;
        const scaleFactor = 39.269;
        const modelScale = 2.5;

        const latestPlayerData = {};
        let yaw = 0, pitch = 0;

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 20000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);
        document.body.appendChild(VRButton.createButton(renderer));

        // Lights
        scene.add(new THREE.AmbientLight(0xffffff, 1.0));
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(100,200,100);
        scene.add(dirLight);

        // VR Controllers
        const controller1 = renderer.xr.getController(0);
        const controller2 = renderer.xr.getController(1);
        scene.add(controller1);
        scene.add(controller2);

        const controllerModelFactory = new XRControllerModelFactory();
        const grip1 = renderer.xr.getControllerGrip(0);
        grip1.add(controllerModelFactory.createControllerModel(grip1));
        scene.add(grip1);
        const grip2 = renderer.xr.getControllerGrip(1);
        grip2.add(controllerModelFactory.createControllerModel(grip2));
        scene.add(grip2);

        // Players
        const playerGeometry = new THREE.CylinderGeometry(1,1,2,8);
        const playerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const playerMeshes = new Map();
        const maxVelocities = new Map();

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let followTarget = null;

        let vrMoveForward = 0, vrMoveRight = 0;

        // Leaderboard UI
        function updateLeaderboard() {
            const tbody = document.getElementById("leaderboard-body");
            tbody.innerHTML = "";
            const sorted = Array.from(maxVelocities.entries()).sort((a,b)=>b[1]-a[1]);
            sorted.forEach(([name,vel],i)=>{
                if(name==="unconnected") return;
                let medal = i===0?"ðŸ¥‡ ":i===1?"ðŸ¥ˆ ":i===2?"ðŸ¥‰ ":"";
                const row = document.createElement("tr");
                row.innerHTML = `<td>${medal}${name}</td><td>${vel.toFixed(2)}</td>`;
                tbody.appendChild(row);
            });
        }

        // Spawn or update a player
        function spawnRealtimePlayerIndicator(data) {
            if (!data || !data.name) return;

            // Transform GMod â†’ Three.js
            const baseX = (data.x - offsetX) / scaleFactor;
            const baseY = (data.z - offsetZ) / scaleFactor;
            const baseZ = -(data.y - offsetY) / scaleFactor;
            const posX = baseX * modelScale;
            const posY = baseY * modelScale + testHeight + 1;
            const posZ = baseZ * modelScale;

            // Track max velocity
            if (data.vel !== undefined) {
                const adjustedVel = data.vel / 10;
                const currentMax = maxVelocities.get(data.name) || 0;
                if (adjustedVel > currentMax) {
                    maxVelocities.set(data.name, adjustedVel);
                    localStorage.setItem("maxVelocities", JSON.stringify(Object.fromEntries(maxVelocities)));
                    updateLeaderboard();
                }
            }

            if (!playerMeshes.has(data.name)) {
                const mesh = new THREE.Mesh(playerGeometry, playerMaterial);
                scene.add(mesh);

                const canvas = document.createElement("canvas");
                canvas.width = 256; canvas.height = 64;
                const ctx = canvas.getContext("2d");
                ctx.fillStyle = "rgba(0,0,0,0.7)";
                ctx.fillRect(0,0,canvas.width,canvas.height);
                ctx.fillStyle="white";
                ctx.font="bold 20px Arial";
                ctx.fillText(data.name,10,35);
                const label = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas) }));
                label.scale.set(20,5,1);
                scene.add(label);

                playerMeshes.set(data.name, { mesh, label, targetPos: new THREE.Vector3() });
            }

            const player = playerMeshes.get(data.name);
            player.targetPos.set(posX,posY,posZ);
            player.label.position.set(posX,posY+3,posZ);

            // Save data globally
            latestPlayerData[data.name] = data;
        }

        // Load map
        const loader = new THREE.GLTFLoader();
        async function loadMap() {
            try {
                const gltf = await new Promise((res,rej)=>{
                    loader.load("/gm_bigcity/scene.gltf",res,(p)=>{
                        const percent = (p.loaded/p.total*100).toFixed(2);
                        document.getElementById("loading").innerText=`Loading map... ${percent}%`;
                    },rej);
                });
                scene.add(gltf.scene);
                gltf.scene.scale.set(2.5,2.5,2.5);
                gltf.scene.position.set(0,15,0);
                document.getElementById("loading").style.display="none";
                initRealtimePlayer();
            } catch(err) {
                console.error("Error loading map:",err);
                document.getElementById("loading").innerText="Failed to load map.";
                setTimeout(()=>{document.getElementById("loading").style.display="none";initRealtimePlayer();},3000);
            }
        }
        loadMap();

        // WebSocket connection
        function initRealtimePlayer() {
            const socket = new WebSocket("wss://emm-mapped.onrender.com/data");
            socket.onopen=()=>console.log("WebSocket connected");
            socket.onmessage=(event)=>{
                try {
                    const msg = JSON.parse(event.data);
                    if (msg.players) {
                        const current = new Set();
                        msg.players.forEach(p=>{
                            spawnRealtimePlayerIndicator(p);
                            current.add(p.name);
                        });
                        playerMeshes.forEach((pl,name)=>{
                            if (!current.has(name)) {
                                scene.remove(pl.mesh); scene.remove(pl.label);
                                playerMeshes.delete(name);
                                updateLeaderboard();
                            }
                        });
                    }
                } catch(e){console.error("Bad WS msg:",e);}
            };
            socket.onclose=()=>console.log("WebSocket closed");
            socket.onerror=(e)=>console.error("WebSocket error:",e);
        }

        // Freecam controls
        const moveSpeed = 50;
        const keys = {w:0,a:0,s:0,d:0,space:0,ctrl:0,tab:0};
        const clock = new THREE.Clock();

        document.addEventListener("keydown",(e)=>{
            switch(e.key.toLowerCase()){
                case "w":keys.w=1;break;
                case "a":keys.a=1;break;
                case "s":keys.s=1;break;
                case "d":keys.d=1;break;
                case " ":keys.space=1;e.preventDefault();break;
                case "control":keys.ctrl=1;break;
                case "tab":keys.tab=1;document.getElementById("leaderboard").style.display="block";e.preventDefault();break;
            }
        });
        document.addEventListener("keyup",(e)=>{
            switch(e.key.toLowerCase()){
                case "w":keys.w=0;break;
                case "a":keys.a=0;break;
                case "s":keys.s=0;break;
                case "d":keys.d=0;break;
                case " ":keys.space=0;break;
                case "control":keys.ctrl=0;break;
                case "tab":keys.tab=0;document.getElementById("leaderboard").style.display="none";break;
            }
        });

        // Mouse look for desktop
        document.addEventListener('mousemove', (e) => {
            if (!renderer.xr.isPresenting && document.pointerLockElement === renderer.domElement) {
                yaw -= e.movementX * 0.002;
                pitch -= e.movementY * 0.002;
                pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
            }
        });

        // Click to follow (desktop)
        document.addEventListener("click",(e)=>{
            renderer.domElement.requestPointerLock();
            mouse.x=(e.clientX/window.innerWidth)*2-1;
            mouse.y=-(e.clientY/window.innerHeight)*2+1;
            raycaster.setFromCamera(mouse,camera);
            const meshes = Array.from(playerMeshes.values()).map(p=>p.mesh);
            const hits=raycaster.intersectObjects(meshes);
            if(hits.length>0){
                const clicked=hits[0].object;
                for(let [name,pl] of playerMeshes.entries()){
                    if(pl.mesh===clicked){
                        followTarget=name;
                        console.log("Following",name);
                        pl.mesh.visible = false;
                        pl.label.visible = false;
                    }
                }
            } else {
                followTarget=null;
                playerMeshes.forEach(p=>{
                    p.mesh.visible = true;
                    p.label.visible = true
                })
            }
        });

        // VR selection
        controller1.addEventListener('selectstart', onSelectStart);
        controller2.addEventListener('selectstart', onSelectStart);

        function onSelectStart(event) {
            const controller = event.target;
            const tempMatrix = new THREE.Matrix4();
            tempMatrix.identity().extractRotation(controller.matrixWorld);
            raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
            const meshes = Array.from(playerMeshes.values()).map(p => p.mesh);
            const hits = raycaster.intersectObjects(meshes);
            if (hits.length > 0) {
                const clicked = hits[0].object;
                for (let [name, pl] of playerMeshes.entries()) {
                    if (pl.mesh === clicked) {
                        followTarget = name;
                        console.log("Following", name);
                        pl.mesh.visible = false;
                        pl.label.visible = false;
                        break;
                    }
                }
            } else {
                followTarget = null;
                playerMeshes.forEach(p => {
                    p.mesh.visible = true;
                    p.label.visible = true;
                });
            }
        }

        // Camera
        camera.position.set(0,50,50);

        // Main loop
        function animate(){
            const delta=clock.getDelta();

            // Lerp players
            playerMeshes.forEach(p=>{
                p.mesh.position.lerp(p.targetPos,0.1);
                p.label.position.copy(p.mesh.position).add(new THREE.Vector3(0,3,0));
            });

            if (renderer.xr.isPresenting) {
                const session = renderer.xr.getSession();
                const inputSources = session.inputSources;
                for (let source of inputSources) {
                    if (source.gamepad && source.handedness === 'left') {
                        vrMoveForward = -source.gamepad.axes[3] || 0; // Adjust axis if needed
                        vrMoveRight = source.gamepad.axes[2] || 0;
                    }
                }
                const speed = moveSpeed * delta;
                const headsetDir = new THREE.Vector3();
                camera.getWorldDirection(headsetDir);
                headsetDir.y = 0;
                headsetDir.normalize();
                const headsetRight = new THREE.Vector3().crossVectors(headsetDir, new THREE.Vector3(0, 1, 0)).normalize();
                camera.position.addScaledVector(headsetDir, vrMoveForward * speed);
                camera.position.addScaledVector(headsetRight, vrMoveRight * speed);
            } else if(!followTarget){
                const speed=moveSpeed*delta;
                const dir=new THREE.Vector3(Math.sin(yaw),0,Math.cos(yaw)).normalize();
                const right=new THREE.Vector3().crossVectors(dir,new THREE.Vector3(0,1,0)).normalize();
                if(keys.w) camera.position.addScaledVector(dir,-speed);
                if(keys.s) camera.position.addScaledVector(dir,speed);
                if(keys.a) camera.position.addScaledVector(right,speed);
                if(keys.d) camera.position.addScaledVector(right,-speed);
                if(keys.space) camera.position.y+=speed;
                if(keys.ctrl) camera.position.y-=speed;
                camera.rotation.set(pitch,yaw,0,"YXZ");
            }

            if(followTarget && playerMeshes.has(followTarget)){
                const playerData=latestPlayerData[followTarget];
                if(playerData){
                    const baseX=(playerData.x-offsetX)/scaleFactor;
                    const baseY=(playerData.z-offsetZ)/scaleFactor;
                    const baseZ=-(playerData.y-offsetY)/scaleFactor;
                    const posX=baseX*modelScale;
                    const posY=baseY*modelScale+testHeight+3;
                    const posZ=baseZ*modelScale;
                    camera.position.set(posX,posY,posZ);

                    const pch=THREE.MathUtils.degToRad(-playerData.pitch||0);
                    const yw=THREE.MathUtils.degToRad(playerData.yaw||0);
                    
                    camera.quaternion.setFromEuler(new THREE.Euler(pch,yw - Math.PI/2,0,"YXZ"));
                }
            }

            renderer.render(scene,camera);
        }
        renderer.setAnimationLoop(animate);

        window.addEventListener("resize",()=>{
            camera.aspect=window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth,window.innerHeight);
        });
    </script>
</body>
</html>
