<!DOCTYPE html>
<html>
<head>
    <title>EMM 3D Map</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-family: Arial; z-index: 100; }
    </style>
</head>
<body>
    <div id="loading">Loading map...</div>
    <script>
        // Set up Three.js scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Sky blue background
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 20000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = false; // Disabled for simplicity
        document.body.appendChild(renderer.domElement);
        // OrbitControls for right-click rotation and scroll wheel zoom
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.minDistance = 10;
        controls.maxDistance = 5000;
        controls.maxPolarAngle = Math.PI / 2; // Restrict to top-down view
        controls.mouseButtons = {
            LEFT: null, // Disable left-click
            RIGHT: THREE.MOUSE.ROTATE, // Right-click to rotate
            MIDDLE: null // Disable middle-click
        };
        controls.enableKeys = false; // Disable keyboard controls
        // Add lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(100, 200, 100);
        scene.add(directionalLight);
        // Basic floor as fallback
        const floorGeometry = new THREE.PlaneGeometry(20000, 20000);
        const floorMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 }); // Bright green
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);
        // Function to spawn/update a single realtime player indicator
        let realtimePlayerMesh = null;
        let realtimePlayerLabel = null;
        function spawnRealtimePlayerIndicator(data) {
            console.log('Spawning/updating realtime player with data:', data);
            if (!data || !data.name || data.x === undefined || data.y === undefined || data.z === undefined) {
                console.warn('Invalid realtime player data:', data);
                return;
            }
            // Coordinate transformation: GMod (x-forward, y-right, z-up) to Three.js (x-right, y-up, z-forward)
            // Offset from aligned spot: GMod (6486.40, -7073.02, -10741.30) -> Three.js (0, 25, 0)
            const offsetX = 6486.40;
            const offsetY = -7073.02;
            const offsetZ = -10741.30;
            const testHeight = 25; // Target y in Three.js for aligned spot
            const scaleFactor = 35; // GMod units to Three.js (1 foot â‰ˆ 16 Hammer units)
            const modelScale = 2.5; // Model scale factor
            const gmodX = data.x;
            const gmodY = data.y;
            const gmodZ = data.z;
            // Calculate base positions (pre-scale)
            const baseX = (gmodX - offsetX) / scaleFactor; // GMod X (forward) -> Three X (right)
            const baseY = (gmodZ - offsetZ) / scaleFactor; // GMod Z (up) -> base Three Y (up)
            const baseZ = -(gmodY - offsetY) / scaleFactor; // GMod Y (right) -> Three Z (forward, flipped)
            // Apply model scale
            const posX = baseX * modelScale;
            const posY = baseY * modelScale + testHeight + 1; // Slight offset above surface
            const posZ = baseZ * modelScale;
            console.log('Transformed position:', {posX, posY, posZ});
            // Create or update player mesh
            if (!realtimePlayerMesh) {
                const playerGeometry = new THREE.CylinderGeometry(1, 1, 2, 8); // Radius 1 (2 units wide), height 2
                const playerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Bright red
                realtimePlayerMesh = new THREE.Mesh(playerGeometry, playerMaterial);
                scene.add(realtimePlayerMesh);
                // Create name label
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                context.fillStyle = 'rgba(0, 0, 0, 0.7)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                context.fillStyle = 'white';
                context.font = 'bold 20px Arial';
                context.fillText(data.name, 10, 35);
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                realtimePlayerLabel = new THREE.Sprite(spriteMaterial);
                realtimePlayerLabel.scale.set(20, 5, 1); // Reasonable label size
                scene.add(realtimePlayerLabel);
                console.log('Created realtime player mesh and label for:', data.name);
            }
            // Update position
            realtimePlayerMesh.position.set(posX, posY, posZ);
            realtimePlayerLabel.position.set(posX, posY + 3, posZ); // Above the cylinder
        }
        // Load gm_bigcity.gltf
        const loader = new THREE.GLTFLoader();
        let mapLoaded = false;
        loader.load(
            '/gm_bigcity/scene.gltf',
            (gltf) => {
                console.log('Map loaded successfully');
                scene.add(gltf.scene);
                gltf.scene.scale.set(2.5, 2.5, 2.5); // Scale up model by 2.5x
                gltf.scene.position.set(0, 15, 0);
                mapLoaded = true;
                document.getElementById('loading').style.display = 'none';
                // Initialize realtime player after map loads
                initRealtimePlayer();
            },
            (progress) => {
                console.log('Loading progress:', (progress.loaded / progress.total * 100) + '%');
            },
            (error) => {
                console.error('Error loading GLTF:', error);
                document.getElementById('loading').innerHTML = 'Failed to load map. Using fallback floor.';
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                    // Initialize realtime player even if map fails
                    initRealtimePlayer();
                }, 3000);
            }
        );
        // Initialize WebSocket for realtime player
        function initRealtimePlayer() {
            const socket = new WebSocket('wss://emm-mapped.onrender.com/data');
            socket.onopen = () => {
                console.log('WebSocket connected for realtime player');
            };
            socket.onmessage = (event) => {
                try {
                    const message = JSON.parse(event.data);
                    if (message.players) {
                        // Assume single player for now; take first
                        const playerData = message.players[0] || message.players;
                        spawnRealtimePlayerIndicator(playerData);
                    }
                } catch (e) {
                    console.error('Error parsing WebSocket message:', e);
                }
            };
            socket.onclose = () => {
                console.log('WebSocket disconnected');
            };
            socket.onerror = (error) => {
                console.error('WebSocket error:', error);
            };
        }
        // Camera setup
        camera.position.set(0, 50, 50);
        controls.target.set(0, 15, 0); // Center of the model
        camera.lookAt(0, 15, 0); // Ensure initial lookAt
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        // Start everything
        animate();
    </script>
</body>
</html>
