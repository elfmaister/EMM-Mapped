<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>EMM 3D Map - VR</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
<style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #loading, #leaderboard, #vrButton {
        position: absolute; top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        font-family: Arial; z-index: 100;
    }
    #loading { color: white; }
    #leaderboard {
        background: rgba(0,0,0,0.8); color: white;
        padding: 20px; border-radius: 8px;
        z-index: 200; display: none; max-height: 80vh; overflow-y: auto;
    }
    #leaderboard table { width: 100%; border-collapse: collapse; }
    #leaderboard th, #leaderboard td { padding: 8px; text-align: left; border-bottom: 1px solid #555; }
    #leaderboard h2 { margin: 0 0 10px; text-align: center; }
    #vrButton {
        top: auto; bottom: 20px; left: auto; right: 20px;
        transform: none; z-index: 300;
        background: #28a; color: white; padding: 10px 20px;
        border-radius: 5px; cursor: pointer;
    }
</style>
</head>
<body>
<div id="loading">Loading map...</div>
<div id="leaderboard">
    <h2>Fastest Velocities</h2>
    <table>
        <thead><tr><th>Player</th><th>Max Velocity (u/s)</th></tr></thead>
        <tbody id="leaderboard-body"></tbody>
    </table>
</div>
<div id="vrButton">Enter VR</div>

<script>
    // -------------------------------
    // Constants & Config
    // -------------------------------
    const offsetX = 6498.061, offsetY = -7027.718, offsetZ = -10647.092;
    const testHeight = 45, scaleFactor = 39.269, modelScale = 2.5;
    const moveSpeed = 50;

    // -------------------------------
    // State Variables
    // -------------------------------
    const latestPlayerData = {};
    const maxVelocities = new Map();
    const playerMeshes = new Map();
    let yaw = 0, pitch = 0;
    const keys = { w:0, a:0, s:0, d:0, space:0, ctrl:0, tab:0 };
    let followTarget = null;

    const clock = new THREE.Clock();
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    // -------------------------------
    // Scene & Renderer
    // -------------------------------
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 20000);
    camera.position.set(0, 150, 0); // Spawn above the map

    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.xr.enabled = true; // Enable WebXR
    document.body.appendChild(renderer.domElement);

    // Lighting
    scene.add(new THREE.AmbientLight(0xffffff, 1.0));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
    dirLight.position.set(100,200,100);
    scene.add(dirLight);

    // Player Mesh
    const playerGeometry = new THREE.CylinderGeometry(1,1,2,8);
    const playerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });

    // -------------------------------
    // Leaderboard
    // -------------------------------
    function updateLeaderboard() {
        const tbody = document.getElementById("leaderboard-body");
        tbody.innerHTML = "";
        Array.from(maxVelocities.entries())
            .sort((a,b) => b[1]-a[1])
            .forEach(([name, vel], i) => {
                if(name === "unconnected") return;
                const medal = i===0?"ðŸ¥‡ ":i===1?"ðŸ¥ˆ ":i===2?"ðŸ¥‰ ":"";
                const row = document.createElement("tr");
                row.innerHTML = `<td>${medal}${name}</td><td>${vel.toFixed(2)}</td>`;
                tbody.appendChild(row);
            });
    }

    // -------------------------------
    // Spawn or Update Player
    // -------------------------------
    function spawnRealtimePlayerIndicator(data) {
        if (!data || !data.name) return;
        const posX = ((data.x - offsetX)/scaleFactor) * modelScale;
        const posY = ((data.z - offsetZ)/scaleFactor) * modelScale + testHeight + 1;
        const posZ = (-(data.y - offsetY)/scaleFactor) * modelScale;

        if(data.vel !== undefined) {
            const adjustedVel = data.vel / 10;
            const currentMax = maxVelocities.get(data.name) || 0;
            if(adjustedVel > currentMax) {
                maxVelocities.set(data.name, adjustedVel);
                localStorage.setItem("maxVelocities", JSON.stringify(Object.fromEntries(maxVelocities)));
                updateLeaderboard();
            }
        }

        if(!playerMeshes.has(data.name)) {
            const mesh = new THREE.Mesh(playerGeometry, playerMaterial);
            scene.add(mesh);

            const canvas = document.createElement("canvas");
            canvas.width=256; canvas.height=64;
            const ctx = canvas.getContext("2d");
            ctx.fillStyle="rgba(0,0,0,0.7)"; ctx.fillRect(0,0,256,64);
            ctx.fillStyle="white"; ctx.font="bold 20px Arial"; ctx.fillText(data.name,10,35);

            const label = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas) }));
            label.scale.set(20,5,1);
            scene.add(label);

            playerMeshes.set(data.name,{mesh,label,targetPos:new THREE.Vector3()});
        }

        const player = playerMeshes.get(data.name);
        player.targetPos.set(posX,posY,posZ);
        player.label.position.set(posX,posY+3,posZ);
        latestPlayerData[data.name] = data;
    }

    // -------------------------------
    // Load Map
    // -------------------------------
    const loader = new THREE.GLTFLoader();
    async function loadMap() {
        try {
            const gltf = await new Promise((res, rej) => {
                loader.load("/gm_bigcity/scene.gltf", res, p => {
                    document.getElementById("loading").innerText = `Loading map... ${(p.loaded/p.total*100).toFixed(2)}%`;
                }, rej);
            });
            scene.add(gltf.scene);
            gltf.scene.scale.set(2.5,2.5,2.5);
            gltf.scene.position.set(0,15,0);
            document.getElementById("loading").style.display="none";
            initRealtimePlayer();
        } catch(err) {
            console.error("Error loading map:", err);
            document.getElementById("loading").innerText="Failed to load map.";
            setTimeout(()=>{document.getElementById("loading").style.display="none"; initRealtimePlayer();},3000);
        }
    }
    loadMap();

    // -------------------------------
    // WebSocket Updates
    // -------------------------------
    function initRealtimePlayer() {
        const socket = new WebSocket("wss://emm-mapped.onrender.com/data");
        socket.onopen = () => console.log("WebSocket connected");
        socket.onmessage = (event) => {
            try {
                const msg = JSON.parse(event.data);
                if(msg.players) {
                    const current = new Set();
                    msg.players.forEach(p => { spawnRealtimePlayerIndicator(p); current.add(p.name); });
                    playerMeshes.forEach((pl,name) => {
                        if(!current.has(name)) { scene.remove(pl.mesh); scene.remove(pl.label); playerMeshes.delete(name); updateLeaderboard(); }
                    });
                }
            } catch(e){ console.error("Bad WS msg:", e); }
        };
        socket.onclose = () => console.log("WebSocket closed");
        socket.onerror = e => console.error("WebSocket error:", e);
    }

    // -------------------------------
    // Input
    // -------------------------------
    document.addEventListener("keydown", e => {
        switch(e.key.toLowerCase()){
            case "w": keys.w=1; break;
            case "a": keys.a=1; break;
            case "s": keys.s=1; break;
            case "d": keys.d=1; break;
            case " ": keys.space=1; e.preventDefault(); break;
            case "control": keys.ctrl=1; break;
            case "tab": keys.tab=1; document.getElementById("leaderboard").style.display="block"; e.preventDefault(); break;
        }
    });
    document.addEventListener("keyup", e => {
        switch(e.key.toLowerCase()){
            case "w": keys.w=0; break;
            case "a": keys.a=0; break;
            case "s": keys.s=0; break;
            case "d": keys.d=0; break;
            case " ": keys.space=0; break;
            case "control": keys.ctrl=0; break;
            case "tab": keys.tab=0; document.getElementById("leaderboard").style.display="none"; break;
        }
    });

    document.addEventListener("click", e => renderer.domElement.requestPointerLock());

    // -------------------------------
    // VR Button
    // -------------------------------
    const vrButton = document.getElementById("vrButton");
    vrButton.addEventListener("click", () => {
        navigator.xr.requestSession("immersive-vr").then(session => {
            renderer.xr.setSession(session);
        }).catch(err => alert("WebXR not supported: " + err));
    });

    // -------------------------------
    // Animation Loop
    // -------------------------------
    function animate() {
        renderer.setAnimationLoop(() => {
            const delta = clock.getDelta();

            // Lerp player positions
            playerMeshes.forEach(p => {
                p.mesh.position.lerp(p.targetPos,0.1);
                p.label.position.copy(p.mesh.position).add(new THREE.Vector3(0,3,0));
            });

            // Freecam movement
            const speed = moveSpeed*delta;
            const dir = new THREE.Vector3(Math.sin(yaw),0,Math.cos(yaw)).normalize();
            const right = new THREE.Vector3().crossVectors(dir,new THREE.Vector3(0,1,0)).normalize();
            if(keys.w) camera.position.addScaledVector(dir,speed);
            if(keys.s) camera.position.addScaledVector(dir,-speed);
            if(keys.a) camera.position.addScaledVector(right,-speed);
            if(keys.d) camera.position.addScaledVector(right,speed);
            if(keys.space) camera.position.y += speed;
            if(keys.ctrl) camera.position.y -= speed;
            camera.rotation.set(pitch,yaw,0,"YXZ");

            renderer.render(scene,camera);
        });
    }
    animate();

    window.addEventListener("resize", ()=>{
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth,window.innerHeight);
    });

</script>
</body>
</html>
